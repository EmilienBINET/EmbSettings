#pragma once
//#define DEBUG_REGISTER
#include "EmbSettings.hpp"
#ifdef DEBUG_REGISTER
#include <iostream>
#endif


namespace emb {
    namespace settings {

        template<typename Type>
        Type SettingsElement::read_setting(std::string const& a_strFileClass, std::string const& a_strKey, Type const& a_tDefaultValue) {
            if (auto const& fileInfo = getFilesMap()[a_strFileClass]) {
                if (auto pInfo = SettingsFileInfo::getFileInfo((*fileInfo)())) {
                    if (auto val = pInfo->tree.template get_optional<Type>(a_strKey)) {
                        return *val;
                    }
                }
            }
            return a_tDefaultValue;
        }

        template<typename Type>
        void SettingsElement::write_setting(std::string const& a_strFileClass, std::string const& a_strKey, Type const& a_tNewValue) {
            if (auto const& fileInfo = getFilesMap()[a_strFileClass]) {
                if (auto pInfo = SettingsFileInfo::getFileInfo((*fileInfo)())) {
                    pInfo->tree.template put<Type>(a_strKey, a_tNewValue);
                }
            }
        }

        template<typename Type, typename Element>
        void SettingsElement::link_setting(std::string const& a_strFileClass, std::string const& a_strKey, Type & a_rtValue) {
            SettingsElement::getLinks()[a_strKey] = std::make_pair([&a_rtValue]{ a_rtValue = Element::read(); }, [&a_rtValue]{ Element::write(a_rtValue); });
        }

        template<typename Type>
        Type SettingsElement::read(Type const& a_tDefaultValue) const {
            return read_setting<Type>(getFileClassName(), getPath(), a_tDefaultValue);
        }
        template<typename Type>
        void SettingsElement::write(Type const& a_tNewValue) const {
            write_setting<Type>(getFileClassName(), getPath(), a_tNewValue);
        }

    }
}
